
--保证所有计算之前先给cells 赋值
function MiaoPeople2:calcG(x, y)
    local key = getMapKey(x, y)
    local data = self.cells[key]

    --if data == nil then
    --    data = {}
    --end
    local parent = data.parent
    local px, py = getXY(parent)
    local difX = math.abs(px-x)
    local difY = math.abs(py-y)
    local dist = 14
    if difX > 0 and difY > 0 then
        dist = 10
    end

    --此块有建筑物 要绕过
    local buildCell = self.map.mapGridController.mapDict
    --是建筑物 不能穿过
    if buildCell[key] ~= nil and buildCell[key][1][1].picName == 'build' then
        dist = 30
    end
    --多个人走到一个cell上面
    if self.map.cells[key] == true then
        dist = 200
    end

    data.gScore = self.cells[parent].gScore+dist

    self.cells[key] = data
end
--寻找的工作目标 空闲建筑物 锁定
function MiaoPeople2:calcH(x, y)
    local key = getMapKey(x, y)
    local data = self.cells[key]

    data.hScore = 10*(math.abs(x-self.predictEnd[1])+math.abs(y-self.predictEnd[2]))
    self.cells[key] = data
end
function MiaoPeople2:calcF(x, y)
    local key = getMapKey(x, y)
    local data = self.cells[key]
    data.fScore = data.gScore+data.hScore
end
function MiaoPeople2:pushQueue(x, y)
    local key = getMapKey(x, y)
    local fScore = self.cells[key].fScore
    heapq.heappush(self.openList, fScore)
    local fDict = self.pqDict[fScore]
    if fDict == nil then
        fDict = {}
    end
    table.insert(fDict, key)
    self.pqDict[fScore] = fDict
end
--先检测近的邻居 再检测远的邻居
function MiaoPeople2:checkNeibor(x, y)
    --近的邻居先访问
    --只允许 正边
    local neibors = {
        {x-1, y-1},
        {x+1, y-1},
        {x+1, y+1},
        {x-1, y+1},
    }
    local curKey = getMapKey(x, y)
    --TrainZone 100 100 2400 400
    local staticObstacle = self.map.staticObstacle 
    local buildCell = self.map.mapGridController.mapDict
    --多个layer 的数据 海水是一个Layer initCell staticObstacle bridge 其它建筑物是另外的cell 
    for n, nv in ipairs(neibors) do
        local key = getMapKey(nv[1], nv[2])
        local cx, cy = normalToCartesian(nv[1], nv[2])
        --小于左边界 则 只能+x
        --有效范围 受到建造范围的控制
        if cx <= 0 and nv[1] < x then
        elseif cx > MapWidth and nv[1] > x then
        elseif cy < 0 and nv[2] < y then
        elseif cy > MapHeight and nv[2] > y then
        else
            local inOpen = false
            local nS
            --不在open 表里面
            --首次加入
            --or staticObstacle[key] ~= nil 
            --没有河流阻碍
            --同一个位置 图层逐渐加上去的 所以检测最后一个层是什么类型即可

            --TODO 只有是ROAD 才能走过
            local hasRoad = false
            if buildCell[key] ~= nil then
                local bb = buildCell[key][#buildCell[key]][1]
                --道路或者 桥梁 建造好的建筑物
                if bb.state == BUILD_STATE.FREE and (bb.picName == 't' or (bb.picName == 'build' and bb.id == 3)) then
                    hasRoad = true
                    print("buildCell Kind Road")
                else
                    print("no road")
                end
            else
                print("not Road")
            end
            --未遍历过 这个邻居 
            --没有 硬性阻碍
            --没有河流
            --有道路
            --如果有建筑物 也可以移动 进去
            local hasBuild = false
            --到达自己的目标建筑物
            if buildCell[key] ~= nil and buildCell[key][#buildCell[key]][1]  == self.predictTarget then
                hasBuild = true
            end
            --使用最短路径 更新parent信息  
            if staticObstacle[key] == nil and (hasRoad or hasBuild) and self.closedList[key] == nil then
                if self.cells[key] == nil then
                    self.cells[key] = {}
                    self.cells[key].parent = curKey
                    self:calcG(nv[1], nv[2])
                    self:calcH(nv[1], nv[2])
                    self:calcF(nv[1], nv[2])
                    self:pushQueue(nv[1], nv[2])
                else
                    local oldParent = self.cells[key]['parent']
                    local oldGScore = self.cells[key]['gScore']
                    local oldFScore = self.cells[key]['fScore']

                    self.cells[key].parent = curKey
                    self:calcG(nv[1], nv[2])
                    if self.cells[key].gScore > oldGScore then
                        self.cells[key]['parent'] = oldParent
                        self.cells[key]['gScore'] = oldGScore
                    else
                        self:calcH(nv[1], nv[2])
                        self:calcF(nv[1], nv[2])
                        --从旧的possible 中删除对象 
                        local oldPossible = self.pqDict[oldFScore]
                        for k, v in ipairs(oldPossible) do
                            if v == key then
                                table.remove(oldPossible, k)
                                break
                            end
                        end
                        self:pushQueue(nv[1], nv[2])
                    end
                end
            end 
        end
    end
    self.closedList[curKey] = true
end
--根据endPoint cells 逆向找到回去的路径
function MiaoPeople2:getPath()
    if self.endPoint ~= nil then
        
        local path = {self.endPoint}
        local parent = self.cells[getMapKey(self.endPoint[1], self.endPoint[2])].parent
        while parent ~= nil do
            local x, y = getXY(parent)
            table.insert(path, {x, y})
            if x == self.startPoint[1] and y == self.startPoint[2] then
                break
            end
            parent = self.cells[parent].parent
        end
        --不包括最后一个点
        for i =#path, 2, -1 do
            table.insert(self.path, {path[i][1], path[i][2]})
        end
        print("getPath", simple.encode(self.endPoint), simple.encode(path))
        
        --走到房间边缘消失掉
        if self.predictTarget.id == 1 then
            local mx, my = (path[1][1]+path[2][1])/2, (path[1][2]+path[2][2])/2
            table.insert(self.path, {mx, my})
            self.tempEndPoint = {path[1][1], path[1][2]}
        --进入工厂中工作
        elseif self.predictTarget.id == 5 then
            print("go into factory !!!!!!!!!!")
            table.insert(self.path, path[1])
        elseif self.predictTarget.id == 2 then
            --进入农田中心去工作
            table.insert(self.path, path[1])
        --商人走到路中心位置
        elseif self.predictTarget.picName == 'backPoint' then
            table.insert(self.path, path[1])
        --进入商店
        elseif self.predictTarget.id == 6 then
            table.insert(self.path, path[1])
        --进入采矿场 进入矿坑
        else
            table.insert(self.path, path[1])
        end
        --设置全局Cell 中此处的权重+10
        if #self.path > 0 then
            self.endPoint = self.path[#self.path]
            --self.map:setCell(self.endPoint)
        end
    end
end


function MiaoPeople2:setDir(xy)
    local x, y = xy[1], xy[2]

    local p = getPos(self.bg)
    local dx = x-p[1]
    local dy = y-p[2]
    if dx > 0 then
        if dy > 0 then
            self.changeDirNode:stopAllActions()
            local ani = CCAnimationCache:sharedAnimationCache():animationByName("people"..self.id.."_rt")
            self.changeDirNode:runAction(repeatForever(CCAnimate:create(ani)))
        elseif dy < 0 then
            self.changeDirNode:stopAllActions()
            local ani = CCAnimationCache:sharedAnimationCache():animationByName("people"..self.id.."_rb")
            self.changeDirNode:runAction(repeatForever(CCAnimate:create(ani)))
        end
    elseif dx < 0 then
        if dy > 0 then
            self.changeDirNode:stopAllActions()
            local ani = CCAnimationCache:sharedAnimationCache():animationByName("people"..self.id.."_lt")
            self.changeDirNode:runAction(repeatForever(CCAnimate:create(ani)))
        elseif dy < 0 then
            self.changeDirNode:stopAllActions()
            local ani = CCAnimationCache:sharedAnimationCache():animationByName("people"..self.id.."_lb")
            self.changeDirNode:runAction(repeatForever(CCAnimate:create(ani)))
        end
    end
end

function MiaoPeople2:setZord()
    local p = getPos(self.bg)
    local zOrd = MAX_BUILD_ZORD-p[2]
    self.bg:setZOrder(zOrd)
end

--规划劳作
--最近的劳作位置
function MiaoPeople2:findWorkBuilding()
    if self.health > 0 then
        local allBuild = self.map.mapGridController.allBuildings
        local allPossible = {}
        for k, v in pairs(allBuild) do
            local ret = false
            if self.id == 2 then
            else
                if k.picName == 'build' and k.owner == nil then
                end
            end
        end
    end
end

function findWorkBuilding()
    local allBuild = self.map.mapGridController.allBuildings
    local num = getLen(allBuild)
    local allPossible = {}
    local allFreeFactory = {}
    local allFreeStore = {}
    local allFreeMine = {}
    local allFreeSmith = {}

    for k, v in pairs(allBuild) do
        --休息结束
        --找农田
        local ret = false
        --商人 不需要 占用 建筑物

        if self.id == 2 then
            --农田没有购买者 走到后发现目标被移除了就取消工作 
            --移动建筑物相当于新建一个建筑物 broken = true
            --避免抢占 owner == nil
            --去农田
            ret = (k.picName == 'build' and k.id == 2 and k.state == BUILD_STATE.FREE and k.workNum > 0 and k.owner == nil)
            --去商店
            if not ret then
                ret = (k.picName == 'build' and k.id == 6 and k.state == BUILD_STATE.FREE and k.workNum > 0 and k.owner == nil)
            end
            --采矿场
            if not ret then
                print("stone ", k.stone)
                ret = (k.picName == 'build' and k.id == 12 and k.state == BUILD_STATE.FREE and k.stone > 0 and k.owner == nil)
            end
            --铁匠铺
            if not ret then
                ret = (k.picName == 'build' and k.id == 13 and k.state == BUILD_STATE.FREE and k.workNum > 0 and k.owner == nil)
            end
        --农民要占用建筑物
        elseif self.id == 1 then
            --两种情况 给 其它工厂运输农作物 丰收状态 
            --生产农作物
            --先不允许并行处理
            if k.picName == 'build' and k.owner == nil then
                if k.id == 2 then
                    ret = (k.state == BUILD_STATE.FREE and k.workNum < 10)
                    if not ret then
                    --可以运送到工厂了 寻找最近的工厂 拉着拉着 没有工厂了怎么办？ 到目标地发现建筑物不在了则停止
                        ret = (k.state == BUILD_STATE.FREE and k.workNum >= 10)
                    end
                    --一条链路

                --去工厂生产产品 运送粮食到工厂 或者 到工厂生产产品
                --运送物资到工厂 如果工厂 的 stone > 0 就可以开始生产了  
                --或者将生产好的产品运送到 商店
                --没有直接去工厂的说法
                --[[
                elseif k.id == 5 then
                    ret = (k.food > 0 and getDefault(k.product, 1, 0) < 10)
                    ret = (k.stone > 0 and getDefault(k.product, 2, 0) < 10)
                    --生产好食物
                    if not ret then
                        ret = (getDefault(k.product, 1, 0) > 0)
                    end
                    --生产好铁器
                    if not ret then
                        ret = (getDefault(k.product, 2, 0) > 0)
                    end
                --]]
                --采矿场
                elseif k.id == 12 then
                    ret = k.stone < 10 
                    --运送矿石到 商店 不同类型商店经营物品不同
                    if not ret then
                        ret = k.stone >= 10
                    end
                elseif k.id == 11 then
                    --ret = k.stone ~= nil and k.stone > 0 
                end
                --工厂 空闲状态 没有粮食储备 且没有其它用户 
            end
            print("build kind ", k.id, k.food, k.owner)
            --空闲工厂 没有生产产品
            --工厂就只管生产产品就得了
            if k.id == 5 and k.owner == nil then
                print("free factory")
                table.insert(allFreeFactory, k)
            end

            --按照大区块划分的AI 区域
            if k.id == 6 and k.workNum < 10 and k.owner == nil then
                table.insert(allFreeStore, k)
            end
            --矿坑
            if k.id == 11 and k.owner == nil then
                table.insert(allFreeMine, k)
            end
            --铁匠铺 卖出武器
            if k.id == 13 and k.workNum < 10 and k.owner == nil then
                table.insert(allFreeSmith, k)
            end
        end

        --print("building state", ret)
        if ret then
            table.insert(allPossible, k)
        end
    end
    print("allPossible", #allPossible)
    print("allFreeFactory num", #allFreeFactory)
    print("allFreeStore num", #allFreeStore)
    print("allFreeSmith num", #allFreeSmith)
    if #allPossible > 0 then
        local rd = math.random(#allPossible)
        local k = allPossible[rd]
        --基本潜质
        --工作种类
        if self.id == 1 then
            --寻找空闲的工厂 运送物资过去
            --寻找最近的工厂运送过去  行为转变了
            if k.id == 2 and k.workNum >= 10 then
                --锁定了农田和 工厂的 使用者
                if #allFreeFactory > 0 and #allFreeStore > 0 then
                    self.stateLabel:setString("findFactory!!!")
                    self.predictFactory = allFreeFactory[1]
                    self.predictFactory:setOwner(self) 
                    self.predictStore = allFreeStore[1]
                    self.predictStore:setOwner(self)
                    k:setOwner(self)
                    self.predictTarget = k
                    print("find Factory !!!!!!!!!!!!!!!!!!!!!", self.predictFactory)
                end
                --种地去
            elseif k.id == 2 and k.workNum < 10 then
                k:setOwner(self)
                self.predictTarget = k
            elseif k.id == 5 then
                --开始生产了
                --还有剩余粮食
                if k.food > 0 then
                    k:setOwner(self)
                    self.predictTarget = k
                --只有生产好的商品
                else
                    if #allFreeStore > 0 then
                        self.predictStore = allFreeStore[1]
                        self.predictStore:setOwner(self)
                        k:setOwner(self)
                        self.predictTarget = k
                    end
                end
            --采矿场
            elseif k.id == 12 then
                --还可以采集石头
                if k.stone < 10 then
                    if #allFreeMine > 0 then
                        self.predictMine = allFreeMine[1]
                        self.predictMine:setOwner(self)
                        self.predictTarget = k
                        k:setOwner(self)
                    end
                --准备生产铁器
                elseif k.stone >= 10 then
                    if #allFreeSmith > 0 and #allFreeFactory > 0 then
                        self.predictFactory = allFreeFactory[1] 
                        self.predictFactory:setOwner(self)
                        self.predictSmith = allFreeSmith[1]
                        self.predictSmith:setOwner(self)
                        self.predictTarget = k
                        k:setOwner(self)
                    end
                end
            end
        --购买粮食
        elseif self.id == 2 then
            --一块农田只有一个购买者
            --购买结束需要clearBuyer
            --一次购买不成功 还会尝试去购买别的
            --去商店购买
            k:setOwner(self)
            self.predictTarget = k
        end
    end 
end

